// Code generated by SQLBoiler 4.13.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// AlarmHistory is an object representing the database table.
type AlarmHistory struct {
	AlarmID   null.Int     `boil:"alarm_id" json:"alarm_id,omitempty" toml:"alarm_id" yaml:"alarm_id,omitempty"`
	AssetID   int          `boil:"asset_id" json:"asset_id" toml:"asset_id" yaml:"asset_id"`
	Subtype   string       `boil:"subtype" json:"subtype" toml:"subtype" yaml:"subtype"`
	Attribute null.String  `boil:"attribute" json:"attribute,omitempty" toml:"attribute" yaml:"attribute,omitempty"`
	Prio      int16        `boil:"prio" json:"prio" toml:"prio" yaml:"prio"`
	Val       null.Float64 `boil:"val" json:"val,omitempty" toml:"val" yaml:"val,omitempty"`
	AckP      bool         `boil:"ack_p" json:"ack_p" toml:"ack_p" yaml:"ack_p"`
	TS        time.Time    `boil:"ts" json:"ts" toml:"ts" yaml:"ts"`
	GoneTS    null.Time    `boil:"gone_ts" json:"gone_ts,omitempty" toml:"gone_ts" yaml:"gone_ts,omitempty"`
	AckTS     null.Time    `boil:"ack_ts" json:"ack_ts,omitempty" toml:"ack_ts" yaml:"ack_ts,omitempty"`
	Multi     int          `boil:"multi" json:"multi" toml:"multi" yaml:"multi"`
	Message   null.JSON    `boil:"message" json:"message,omitempty" toml:"message" yaml:"message,omitempty"`
	AckText   null.String  `boil:"ack_text" json:"ack_text,omitempty" toml:"ack_text" yaml:"ack_text,omitempty"`
	AckUserID null.String  `boil:"ack_user_id" json:"ack_user_id,omitempty" toml:"ack_user_id" yaml:"ack_user_id,omitempty"`

	R *alarmHistoryR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L alarmHistoryL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var AlarmHistoryColumns = struct {
	AlarmID   string
	AssetID   string
	Subtype   string
	Attribute string
	Prio      string
	Val       string
	AckP      string
	TS        string
	GoneTS    string
	AckTS     string
	Multi     string
	Message   string
	AckText   string
	AckUserID string
}{
	AlarmID:   "alarm_id",
	AssetID:   "asset_id",
	Subtype:   "subtype",
	Attribute: "attribute",
	Prio:      "prio",
	Val:       "val",
	AckP:      "ack_p",
	TS:        "ts",
	GoneTS:    "gone_ts",
	AckTS:     "ack_ts",
	Multi:     "multi",
	Message:   "message",
	AckText:   "ack_text",
	AckUserID: "ack_user_id",
}

var AlarmHistoryTableColumns = struct {
	AlarmID   string
	AssetID   string
	Subtype   string
	Attribute string
	Prio      string
	Val       string
	AckP      string
	TS        string
	GoneTS    string
	AckTS     string
	Multi     string
	Message   string
	AckText   string
	AckUserID string
}{
	AlarmID:   "alarm_history.alarm_id",
	AssetID:   "alarm_history.asset_id",
	Subtype:   "alarm_history.subtype",
	Attribute: "alarm_history.attribute",
	Prio:      "alarm_history.prio",
	Val:       "alarm_history.val",
	AckP:      "alarm_history.ack_p",
	TS:        "alarm_history.ts",
	GoneTS:    "alarm_history.gone_ts",
	AckTS:     "alarm_history.ack_ts",
	Multi:     "alarm_history.multi",
	Message:   "alarm_history.message",
	AckText:   "alarm_history.ack_text",
	AckUserID: "alarm_history.ack_user_id",
}

// Generated where

var AlarmHistoryWhere = struct {
	AlarmID   whereHelpernull_Int
	AssetID   whereHelperint
	Subtype   whereHelperstring
	Attribute whereHelpernull_String
	Prio      whereHelperint16
	Val       whereHelpernull_Float64
	AckP      whereHelperbool
	TS        whereHelpertime_Time
	GoneTS    whereHelpernull_Time
	AckTS     whereHelpernull_Time
	Multi     whereHelperint
	Message   whereHelpernull_JSON
	AckText   whereHelpernull_String
	AckUserID whereHelpernull_String
}{
	AlarmID:   whereHelpernull_Int{field: "\"alarm_history\".\"alarm_id\""},
	AssetID:   whereHelperint{field: "\"alarm_history\".\"asset_id\""},
	Subtype:   whereHelperstring{field: "\"alarm_history\".\"subtype\""},
	Attribute: whereHelpernull_String{field: "\"alarm_history\".\"attribute\""},
	Prio:      whereHelperint16{field: "\"alarm_history\".\"prio\""},
	Val:       whereHelpernull_Float64{field: "\"alarm_history\".\"val\""},
	AckP:      whereHelperbool{field: "\"alarm_history\".\"ack_p\""},
	TS:        whereHelpertime_Time{field: "\"alarm_history\".\"ts\""},
	GoneTS:    whereHelpernull_Time{field: "\"alarm_history\".\"gone_ts\""},
	AckTS:     whereHelpernull_Time{field: "\"alarm_history\".\"ack_ts\""},
	Multi:     whereHelperint{field: "\"alarm_history\".\"multi\""},
	Message:   whereHelpernull_JSON{field: "\"alarm_history\".\"message\""},
	AckText:   whereHelpernull_String{field: "\"alarm_history\".\"ack_text\""},
	AckUserID: whereHelpernull_String{field: "\"alarm_history\".\"ack_user_id\""},
}

// AlarmHistoryRels is where relationship names are stored.
var AlarmHistoryRels = struct {
}{}

// alarmHistoryR is where relationships are stored.
type alarmHistoryR struct {
}

// NewStruct creates a new relationship struct
func (*alarmHistoryR) NewStruct() *alarmHistoryR {
	return &alarmHistoryR{}
}

// alarmHistoryL is where Load methods for each relationship are stored.
type alarmHistoryL struct{}

var (
	alarmHistoryAllColumns            = []string{"alarm_id", "asset_id", "subtype", "attribute", "prio", "val", "ack_p", "ts", "gone_ts", "ack_ts", "multi", "message", "ack_text", "ack_user_id"}
	alarmHistoryColumnsWithoutDefault = []string{"asset_id", "subtype", "prio", "ack_p", "ts", "multi"}
	alarmHistoryColumnsWithDefault    = []string{"alarm_id", "attribute", "val", "gone_ts", "ack_ts", "message", "ack_text", "ack_user_id"}
	alarmHistoryPrimaryKeyColumns     = []string{"ts", "asset_id", "subtype"}
	alarmHistoryGeneratedColumns      = []string{}
)

type (
	// AlarmHistorySlice is an alias for a slice of pointers to AlarmHistory.
	// This should almost always be used instead of []AlarmHistory.
	AlarmHistorySlice []*AlarmHistory
	// AlarmHistoryHook is the signature for custom AlarmHistory hook methods
	AlarmHistoryHook func(context.Context, boil.ContextExecutor, *AlarmHistory) error

	alarmHistoryQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	alarmHistoryType                 = reflect.TypeOf(&AlarmHistory{})
	alarmHistoryMapping              = queries.MakeStructMapping(alarmHistoryType)
	alarmHistoryPrimaryKeyMapping, _ = queries.BindMapping(alarmHistoryType, alarmHistoryMapping, alarmHistoryPrimaryKeyColumns)
	alarmHistoryInsertCacheMut       sync.RWMutex
	alarmHistoryInsertCache          = make(map[string]insertCache)
	alarmHistoryUpdateCacheMut       sync.RWMutex
	alarmHistoryUpdateCache          = make(map[string]updateCache)
	alarmHistoryUpsertCacheMut       sync.RWMutex
	alarmHistoryUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var alarmHistoryAfterSelectHooks []AlarmHistoryHook

var alarmHistoryBeforeInsertHooks []AlarmHistoryHook
var alarmHistoryAfterInsertHooks []AlarmHistoryHook

var alarmHistoryBeforeUpdateHooks []AlarmHistoryHook
var alarmHistoryAfterUpdateHooks []AlarmHistoryHook

var alarmHistoryBeforeDeleteHooks []AlarmHistoryHook
var alarmHistoryAfterDeleteHooks []AlarmHistoryHook

var alarmHistoryBeforeUpsertHooks []AlarmHistoryHook
var alarmHistoryAfterUpsertHooks []AlarmHistoryHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *AlarmHistory) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range alarmHistoryAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *AlarmHistory) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range alarmHistoryBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *AlarmHistory) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range alarmHistoryAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *AlarmHistory) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range alarmHistoryBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *AlarmHistory) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range alarmHistoryAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *AlarmHistory) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range alarmHistoryBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *AlarmHistory) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range alarmHistoryAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *AlarmHistory) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range alarmHistoryBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *AlarmHistory) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range alarmHistoryAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddAlarmHistoryHook registers your hook function for all future operations.
func AddAlarmHistoryHook(hookPoint boil.HookPoint, alarmHistoryHook AlarmHistoryHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		alarmHistoryAfterSelectHooks = append(alarmHistoryAfterSelectHooks, alarmHistoryHook)
	case boil.BeforeInsertHook:
		alarmHistoryBeforeInsertHooks = append(alarmHistoryBeforeInsertHooks, alarmHistoryHook)
	case boil.AfterInsertHook:
		alarmHistoryAfterInsertHooks = append(alarmHistoryAfterInsertHooks, alarmHistoryHook)
	case boil.BeforeUpdateHook:
		alarmHistoryBeforeUpdateHooks = append(alarmHistoryBeforeUpdateHooks, alarmHistoryHook)
	case boil.AfterUpdateHook:
		alarmHistoryAfterUpdateHooks = append(alarmHistoryAfterUpdateHooks, alarmHistoryHook)
	case boil.BeforeDeleteHook:
		alarmHistoryBeforeDeleteHooks = append(alarmHistoryBeforeDeleteHooks, alarmHistoryHook)
	case boil.AfterDeleteHook:
		alarmHistoryAfterDeleteHooks = append(alarmHistoryAfterDeleteHooks, alarmHistoryHook)
	case boil.BeforeUpsertHook:
		alarmHistoryBeforeUpsertHooks = append(alarmHistoryBeforeUpsertHooks, alarmHistoryHook)
	case boil.AfterUpsertHook:
		alarmHistoryAfterUpsertHooks = append(alarmHistoryAfterUpsertHooks, alarmHistoryHook)
	}
}

// One returns a single alarmHistory record from the query.
func (q alarmHistoryQuery) One(ctx context.Context, exec boil.ContextExecutor) (*AlarmHistory, error) {
	o := &AlarmHistory{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for alarm_history")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all AlarmHistory records from the query.
func (q alarmHistoryQuery) All(ctx context.Context, exec boil.ContextExecutor) (AlarmHistorySlice, error) {
	var o []*AlarmHistory

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to AlarmHistory slice")
	}

	if len(alarmHistoryAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all AlarmHistory records in the query.
func (q alarmHistoryQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count alarm_history rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q alarmHistoryQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if alarm_history exists")
	}

	return count > 0, nil
}

// AlarmHistories retrieves all the records using an executor.
func AlarmHistories(mods ...qm.QueryMod) alarmHistoryQuery {
	mods = append(mods, qm.From("\"alarm_history\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"alarm_history\".*"})
	}

	return alarmHistoryQuery{q}
}

// FindAlarmHistory retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindAlarmHistory(ctx context.Context, exec boil.ContextExecutor, tS time.Time, assetID int, subtype string, selectCols ...string) (*AlarmHistory, error) {
	alarmHistoryObj := &AlarmHistory{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"alarm_history\" where \"ts\"=$1 AND \"asset_id\"=$2 AND \"subtype\"=$3", sel,
	)

	q := queries.Raw(query, tS, assetID, subtype)

	err := q.Bind(ctx, exec, alarmHistoryObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from alarm_history")
	}

	if err = alarmHistoryObj.doAfterSelectHooks(ctx, exec); err != nil {
		return alarmHistoryObj, err
	}

	return alarmHistoryObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *AlarmHistory) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no alarm_history provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(alarmHistoryColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	alarmHistoryInsertCacheMut.RLock()
	cache, cached := alarmHistoryInsertCache[key]
	alarmHistoryInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			alarmHistoryAllColumns,
			alarmHistoryColumnsWithDefault,
			alarmHistoryColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(alarmHistoryType, alarmHistoryMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(alarmHistoryType, alarmHistoryMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"alarm_history\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"alarm_history\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into alarm_history")
	}

	if !cached {
		alarmHistoryInsertCacheMut.Lock()
		alarmHistoryInsertCache[key] = cache
		alarmHistoryInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the AlarmHistory.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *AlarmHistory) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	alarmHistoryUpdateCacheMut.RLock()
	cache, cached := alarmHistoryUpdateCache[key]
	alarmHistoryUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			alarmHistoryAllColumns,
			alarmHistoryPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update alarm_history, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"alarm_history\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, alarmHistoryPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(alarmHistoryType, alarmHistoryMapping, append(wl, alarmHistoryPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update alarm_history row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for alarm_history")
	}

	if !cached {
		alarmHistoryUpdateCacheMut.Lock()
		alarmHistoryUpdateCache[key] = cache
		alarmHistoryUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q alarmHistoryQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for alarm_history")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for alarm_history")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o AlarmHistorySlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), alarmHistoryPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"alarm_history\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, alarmHistoryPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in alarmHistory slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all alarmHistory")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *AlarmHistory) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no alarm_history provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(alarmHistoryColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	alarmHistoryUpsertCacheMut.RLock()
	cache, cached := alarmHistoryUpsertCache[key]
	alarmHistoryUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			alarmHistoryAllColumns,
			alarmHistoryColumnsWithDefault,
			alarmHistoryColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			alarmHistoryAllColumns,
			alarmHistoryPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("models: unable to upsert alarm_history, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(alarmHistoryPrimaryKeyColumns))
			copy(conflict, alarmHistoryPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"alarm_history\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(alarmHistoryType, alarmHistoryMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(alarmHistoryType, alarmHistoryMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "models: unable to upsert alarm_history")
	}

	if !cached {
		alarmHistoryUpsertCacheMut.Lock()
		alarmHistoryUpsertCache[key] = cache
		alarmHistoryUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single AlarmHistory record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *AlarmHistory) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no AlarmHistory provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), alarmHistoryPrimaryKeyMapping)
	sql := "DELETE FROM \"alarm_history\" WHERE \"ts\"=$1 AND \"asset_id\"=$2 AND \"subtype\"=$3"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from alarm_history")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for alarm_history")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q alarmHistoryQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no alarmHistoryQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from alarm_history")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for alarm_history")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o AlarmHistorySlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(alarmHistoryBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), alarmHistoryPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"alarm_history\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, alarmHistoryPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from alarmHistory slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for alarm_history")
	}

	if len(alarmHistoryAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *AlarmHistory) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindAlarmHistory(ctx, exec, o.TS, o.AssetID, o.Subtype)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *AlarmHistorySlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := AlarmHistorySlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), alarmHistoryPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"alarm_history\".* FROM \"alarm_history\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, alarmHistoryPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in AlarmHistorySlice")
	}

	*o = slice

	return nil
}

// AlarmHistoryExists checks if the AlarmHistory row exists.
func AlarmHistoryExists(ctx context.Context, exec boil.ContextExecutor, tS time.Time, assetID int, subtype string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"alarm_history\" where \"ts\"=$1 AND \"asset_id\"=$2 AND \"subtype\"=$3 limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, tS, assetID, subtype)
	}
	row := exec.QueryRowContext(ctx, sql, tS, assetID, subtype)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if alarm_history exists")
	}

	return exists, nil
}
