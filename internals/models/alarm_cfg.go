// Code generated by SQLBoiler 4.13.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/v4/types"
	"github.com/volatiletech/strmangle"
)

// AlarmCFG is an object representing the database table.
type AlarmCFG struct {
	AlarmID    int               `boil:"alarm_id" json:"alarm_id" toml:"alarm_id" yaml:"alarm_id"`
	AssetID    int               `boil:"asset_id" json:"asset_id" toml:"asset_id" yaml:"asset_id"`
	Subtype    string            `boil:"subtype" json:"subtype" toml:"subtype" yaml:"subtype"`
	Attribute  string            `boil:"attribute" json:"attribute" toml:"attribute" yaml:"attribute"`
	Enable     bool              `boil:"enable" json:"enable" toml:"enable" yaml:"enable"`
	Prio       int16             `boil:"prio" json:"prio" toml:"prio" yaml:"prio"`
	AckP       bool              `boil:"ack_p" json:"ack_p" toml:"ack_p" yaml:"ack_p"`
	AutoQuench null.String       `boil:"auto_quench" json:"auto_quench,omitempty" toml:"auto_quench" yaml:"auto_quench,omitempty"`
	Equal      null.Float64      `boil:"equal" json:"equal,omitempty" toml:"equal" yaml:"equal,omitempty"`
	Low        null.Float64      `boil:"low" json:"low,omitempty" toml:"low" yaml:"low,omitempty"`
	High       null.Float64      `boil:"high" json:"high,omitempty" toml:"high" yaml:"high,omitempty"`
	Message    null.JSON         `boil:"message" json:"message,omitempty" toml:"message" yaml:"message,omitempty"`
	Subject    null.String       `boil:"subject" json:"subject,omitempty" toml:"subject" yaml:"subject,omitempty"`
	Urldoc     null.String       `boil:"urldoc" json:"urldoc,omitempty" toml:"urldoc" yaml:"urldoc,omitempty"`
	NotifyOn   null.String       `boil:"notify_on" json:"notify_on,omitempty" toml:"notify_on" yaml:"notify_on,omitempty"`
	DontMask   bool              `boil:"dont_mask" json:"dont_mask" toml:"dont_mask" yaml:"dont_mask"`
	Tags       types.StringArray `boil:"tags" json:"tags,omitempty" toml:"tags" yaml:"tags,omitempty"`

	R *alarmCFGR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L alarmCFGL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var AlarmCFGColumns = struct {
	AlarmID    string
	AssetID    string
	Subtype    string
	Attribute  string
	Enable     string
	Prio       string
	AckP       string
	AutoQuench string
	Equal      string
	Low        string
	High       string
	Message    string
	Subject    string
	Urldoc     string
	NotifyOn   string
	DontMask   string
	Tags       string
}{
	AlarmID:    "alarm_id",
	AssetID:    "asset_id",
	Subtype:    "subtype",
	Attribute:  "attribute",
	Enable:     "enable",
	Prio:       "prio",
	AckP:       "ack_p",
	AutoQuench: "auto_quench",
	Equal:      "equal",
	Low:        "low",
	High:       "high",
	Message:    "message",
	Subject:    "subject",
	Urldoc:     "urldoc",
	NotifyOn:   "notify_on",
	DontMask:   "dont_mask",
	Tags:       "tags",
}

var AlarmCFGTableColumns = struct {
	AlarmID    string
	AssetID    string
	Subtype    string
	Attribute  string
	Enable     string
	Prio       string
	AckP       string
	AutoQuench string
	Equal      string
	Low        string
	High       string
	Message    string
	Subject    string
	Urldoc     string
	NotifyOn   string
	DontMask   string
	Tags       string
}{
	AlarmID:    "alarm_cfg.alarm_id",
	AssetID:    "alarm_cfg.asset_id",
	Subtype:    "alarm_cfg.subtype",
	Attribute:  "alarm_cfg.attribute",
	Enable:     "alarm_cfg.enable",
	Prio:       "alarm_cfg.prio",
	AckP:       "alarm_cfg.ack_p",
	AutoQuench: "alarm_cfg.auto_quench",
	Equal:      "alarm_cfg.equal",
	Low:        "alarm_cfg.low",
	High:       "alarm_cfg.high",
	Message:    "alarm_cfg.message",
	Subject:    "alarm_cfg.subject",
	Urldoc:     "alarm_cfg.urldoc",
	NotifyOn:   "alarm_cfg.notify_on",
	DontMask:   "alarm_cfg.dont_mask",
	Tags:       "alarm_cfg.tags",
}

// Generated where

type whereHelperstring struct{ field string }

func (w whereHelperstring) EQ(x string) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperstring) NEQ(x string) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperstring) LT(x string) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperstring) LTE(x string) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperstring) GT(x string) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperstring) GTE(x string) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }
func (w whereHelperstring) IN(slice []string) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelperstring) NIN(slice []string) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

type whereHelpernull_JSON struct{ field string }

func (w whereHelpernull_JSON) EQ(x null.JSON) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_JSON) NEQ(x null.JSON) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_JSON) LT(x null.JSON) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_JSON) LTE(x null.JSON) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_JSON) GT(x null.JSON) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_JSON) GTE(x null.JSON) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

func (w whereHelpernull_JSON) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_JSON) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

type whereHelpertypes_StringArray struct{ field string }

func (w whereHelpertypes_StringArray) EQ(x types.StringArray) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpertypes_StringArray) NEQ(x types.StringArray) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpertypes_StringArray) LT(x types.StringArray) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpertypes_StringArray) LTE(x types.StringArray) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpertypes_StringArray) GT(x types.StringArray) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpertypes_StringArray) GTE(x types.StringArray) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

func (w whereHelpertypes_StringArray) IsNull() qm.QueryMod { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpertypes_StringArray) IsNotNull() qm.QueryMod {
	return qmhelper.WhereIsNotNull(w.field)
}

var AlarmCFGWhere = struct {
	AlarmID    whereHelperint
	AssetID    whereHelperint
	Subtype    whereHelperstring
	Attribute  whereHelperstring
	Enable     whereHelperbool
	Prio       whereHelperint16
	AckP       whereHelperbool
	AutoQuench whereHelpernull_String
	Equal      whereHelpernull_Float64
	Low        whereHelpernull_Float64
	High       whereHelpernull_Float64
	Message    whereHelpernull_JSON
	Subject    whereHelpernull_String
	Urldoc     whereHelpernull_String
	NotifyOn   whereHelpernull_String
	DontMask   whereHelperbool
	Tags       whereHelpertypes_StringArray
}{
	AlarmID:    whereHelperint{field: "\"alarm_cfg\".\"alarm_id\""},
	AssetID:    whereHelperint{field: "\"alarm_cfg\".\"asset_id\""},
	Subtype:    whereHelperstring{field: "\"alarm_cfg\".\"subtype\""},
	Attribute:  whereHelperstring{field: "\"alarm_cfg\".\"attribute\""},
	Enable:     whereHelperbool{field: "\"alarm_cfg\".\"enable\""},
	Prio:       whereHelperint16{field: "\"alarm_cfg\".\"prio\""},
	AckP:       whereHelperbool{field: "\"alarm_cfg\".\"ack_p\""},
	AutoQuench: whereHelpernull_String{field: "\"alarm_cfg\".\"auto_quench\""},
	Equal:      whereHelpernull_Float64{field: "\"alarm_cfg\".\"equal\""},
	Low:        whereHelpernull_Float64{field: "\"alarm_cfg\".\"low\""},
	High:       whereHelpernull_Float64{field: "\"alarm_cfg\".\"high\""},
	Message:    whereHelpernull_JSON{field: "\"alarm_cfg\".\"message\""},
	Subject:    whereHelpernull_String{field: "\"alarm_cfg\".\"subject\""},
	Urldoc:     whereHelpernull_String{field: "\"alarm_cfg\".\"urldoc\""},
	NotifyOn:   whereHelpernull_String{field: "\"alarm_cfg\".\"notify_on\""},
	DontMask:   whereHelperbool{field: "\"alarm_cfg\".\"dont_mask\""},
	Tags:       whereHelpertypes_StringArray{field: "\"alarm_cfg\".\"tags\""},
}

// AlarmCFGRels is where relationship names are stored.
var AlarmCFGRels = struct {
}{}

// alarmCFGR is where relationships are stored.
type alarmCFGR struct {
}

// NewStruct creates a new relationship struct
func (*alarmCFGR) NewStruct() *alarmCFGR {
	return &alarmCFGR{}
}

// alarmCFGL is where Load methods for each relationship are stored.
type alarmCFGL struct{}

var (
	alarmCFGAllColumns            = []string{"alarm_id", "asset_id", "subtype", "attribute", "enable", "prio", "ack_p", "auto_quench", "equal", "low", "high", "message", "subject", "urldoc", "notify_on", "dont_mask", "tags"}
	alarmCFGColumnsWithoutDefault = []string{"asset_id", "attribute", "prio", "ack_p"}
	alarmCFGColumnsWithDefault    = []string{"alarm_id", "subtype", "enable", "auto_quench", "equal", "low", "high", "message", "subject", "urldoc", "notify_on", "dont_mask", "tags"}
	alarmCFGPrimaryKeyColumns     = []string{"alarm_id"}
	alarmCFGGeneratedColumns      = []string{}
)

type (
	// AlarmCFGSlice is an alias for a slice of pointers to AlarmCFG.
	// This should almost always be used instead of []AlarmCFG.
	AlarmCFGSlice []*AlarmCFG
	// AlarmCFGHook is the signature for custom AlarmCFG hook methods
	AlarmCFGHook func(context.Context, boil.ContextExecutor, *AlarmCFG) error

	alarmCFGQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	alarmCFGType                 = reflect.TypeOf(&AlarmCFG{})
	alarmCFGMapping              = queries.MakeStructMapping(alarmCFGType)
	alarmCFGPrimaryKeyMapping, _ = queries.BindMapping(alarmCFGType, alarmCFGMapping, alarmCFGPrimaryKeyColumns)
	alarmCFGInsertCacheMut       sync.RWMutex
	alarmCFGInsertCache          = make(map[string]insertCache)
	alarmCFGUpdateCacheMut       sync.RWMutex
	alarmCFGUpdateCache          = make(map[string]updateCache)
	alarmCFGUpsertCacheMut       sync.RWMutex
	alarmCFGUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var alarmCFGAfterSelectHooks []AlarmCFGHook

var alarmCFGBeforeInsertHooks []AlarmCFGHook
var alarmCFGAfterInsertHooks []AlarmCFGHook

var alarmCFGBeforeUpdateHooks []AlarmCFGHook
var alarmCFGAfterUpdateHooks []AlarmCFGHook

var alarmCFGBeforeDeleteHooks []AlarmCFGHook
var alarmCFGAfterDeleteHooks []AlarmCFGHook

var alarmCFGBeforeUpsertHooks []AlarmCFGHook
var alarmCFGAfterUpsertHooks []AlarmCFGHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *AlarmCFG) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range alarmCFGAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *AlarmCFG) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range alarmCFGBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *AlarmCFG) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range alarmCFGAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *AlarmCFG) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range alarmCFGBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *AlarmCFG) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range alarmCFGAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *AlarmCFG) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range alarmCFGBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *AlarmCFG) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range alarmCFGAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *AlarmCFG) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range alarmCFGBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *AlarmCFG) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range alarmCFGAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddAlarmCFGHook registers your hook function for all future operations.
func AddAlarmCFGHook(hookPoint boil.HookPoint, alarmCFGHook AlarmCFGHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		alarmCFGAfterSelectHooks = append(alarmCFGAfterSelectHooks, alarmCFGHook)
	case boil.BeforeInsertHook:
		alarmCFGBeforeInsertHooks = append(alarmCFGBeforeInsertHooks, alarmCFGHook)
	case boil.AfterInsertHook:
		alarmCFGAfterInsertHooks = append(alarmCFGAfterInsertHooks, alarmCFGHook)
	case boil.BeforeUpdateHook:
		alarmCFGBeforeUpdateHooks = append(alarmCFGBeforeUpdateHooks, alarmCFGHook)
	case boil.AfterUpdateHook:
		alarmCFGAfterUpdateHooks = append(alarmCFGAfterUpdateHooks, alarmCFGHook)
	case boil.BeforeDeleteHook:
		alarmCFGBeforeDeleteHooks = append(alarmCFGBeforeDeleteHooks, alarmCFGHook)
	case boil.AfterDeleteHook:
		alarmCFGAfterDeleteHooks = append(alarmCFGAfterDeleteHooks, alarmCFGHook)
	case boil.BeforeUpsertHook:
		alarmCFGBeforeUpsertHooks = append(alarmCFGBeforeUpsertHooks, alarmCFGHook)
	case boil.AfterUpsertHook:
		alarmCFGAfterUpsertHooks = append(alarmCFGAfterUpsertHooks, alarmCFGHook)
	}
}

// One returns a single alarmCFG record from the query.
func (q alarmCFGQuery) One(ctx context.Context, exec boil.ContextExecutor) (*AlarmCFG, error) {
	o := &AlarmCFG{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for alarm_cfg")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all AlarmCFG records from the query.
func (q alarmCFGQuery) All(ctx context.Context, exec boil.ContextExecutor) (AlarmCFGSlice, error) {
	var o []*AlarmCFG

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to AlarmCFG slice")
	}

	if len(alarmCFGAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all AlarmCFG records in the query.
func (q alarmCFGQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count alarm_cfg rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q alarmCFGQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if alarm_cfg exists")
	}

	return count > 0, nil
}

// AlarmCFGS retrieves all the records using an executor.
func AlarmCFGS(mods ...qm.QueryMod) alarmCFGQuery {
	mods = append(mods, qm.From("\"alarm_cfg\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"alarm_cfg\".*"})
	}

	return alarmCFGQuery{q}
}

// FindAlarmCFG retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindAlarmCFG(ctx context.Context, exec boil.ContextExecutor, alarmID int, selectCols ...string) (*AlarmCFG, error) {
	alarmCFGObj := &AlarmCFG{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"alarm_cfg\" where \"alarm_id\"=$1", sel,
	)

	q := queries.Raw(query, alarmID)

	err := q.Bind(ctx, exec, alarmCFGObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from alarm_cfg")
	}

	if err = alarmCFGObj.doAfterSelectHooks(ctx, exec); err != nil {
		return alarmCFGObj, err
	}

	return alarmCFGObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *AlarmCFG) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no alarm_cfg provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(alarmCFGColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	alarmCFGInsertCacheMut.RLock()
	cache, cached := alarmCFGInsertCache[key]
	alarmCFGInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			alarmCFGAllColumns,
			alarmCFGColumnsWithDefault,
			alarmCFGColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(alarmCFGType, alarmCFGMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(alarmCFGType, alarmCFGMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"alarm_cfg\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"alarm_cfg\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into alarm_cfg")
	}

	if !cached {
		alarmCFGInsertCacheMut.Lock()
		alarmCFGInsertCache[key] = cache
		alarmCFGInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the AlarmCFG.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *AlarmCFG) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	alarmCFGUpdateCacheMut.RLock()
	cache, cached := alarmCFGUpdateCache[key]
	alarmCFGUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			alarmCFGAllColumns,
			alarmCFGPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update alarm_cfg, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"alarm_cfg\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, alarmCFGPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(alarmCFGType, alarmCFGMapping, append(wl, alarmCFGPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update alarm_cfg row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for alarm_cfg")
	}

	if !cached {
		alarmCFGUpdateCacheMut.Lock()
		alarmCFGUpdateCache[key] = cache
		alarmCFGUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q alarmCFGQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for alarm_cfg")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for alarm_cfg")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o AlarmCFGSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), alarmCFGPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"alarm_cfg\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, alarmCFGPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in alarmCFG slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all alarmCFG")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *AlarmCFG) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no alarm_cfg provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(alarmCFGColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	alarmCFGUpsertCacheMut.RLock()
	cache, cached := alarmCFGUpsertCache[key]
	alarmCFGUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			alarmCFGAllColumns,
			alarmCFGColumnsWithDefault,
			alarmCFGColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			alarmCFGAllColumns,
			alarmCFGPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("models: unable to upsert alarm_cfg, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(alarmCFGPrimaryKeyColumns))
			copy(conflict, alarmCFGPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"alarm_cfg\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(alarmCFGType, alarmCFGMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(alarmCFGType, alarmCFGMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "models: unable to upsert alarm_cfg")
	}

	if !cached {
		alarmCFGUpsertCacheMut.Lock()
		alarmCFGUpsertCache[key] = cache
		alarmCFGUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single AlarmCFG record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *AlarmCFG) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no AlarmCFG provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), alarmCFGPrimaryKeyMapping)
	sql := "DELETE FROM \"alarm_cfg\" WHERE \"alarm_id\"=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from alarm_cfg")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for alarm_cfg")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q alarmCFGQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no alarmCFGQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from alarm_cfg")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for alarm_cfg")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o AlarmCFGSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(alarmCFGBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), alarmCFGPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"alarm_cfg\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, alarmCFGPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from alarmCFG slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for alarm_cfg")
	}

	if len(alarmCFGAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *AlarmCFG) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindAlarmCFG(ctx, exec, o.AlarmID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *AlarmCFGSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := AlarmCFGSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), alarmCFGPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"alarm_cfg\".* FROM \"alarm_cfg\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, alarmCFGPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in AlarmCFGSlice")
	}

	*o = slice

	return nil
}

// AlarmCFGExists checks if the AlarmCFG row exists.
func AlarmCFGExists(ctx context.Context, exec boil.ContextExecutor, alarmID int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"alarm_cfg\" where \"alarm_id\"=$1 limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, alarmID)
	}
	row := exec.QueryRowContext(ctx, sql, alarmID)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if alarm_cfg exists")
	}

	return exists, nil
}
