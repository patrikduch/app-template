// Code generated by SQLBoiler 4.13.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/v4/types"
	"github.com/volatiletech/strmangle"
)

// IosysAccess is an object representing the database table.
type IosysAccess struct {
	ID             int               `boil:"id" json:"id" toml:"id" yaml:"id"`
	DeviceID       int               `boil:"device_id" json:"device_id" toml:"device_id" yaml:"device_id"`
	Iosvar         string            `boil:"iosvar" json:"iosvar" toml:"iosvar" yaml:"iosvar"`
	Iostype        null.String       `boil:"iostype" json:"iostype,omitempty" toml:"iostype" yaml:"iostype,omitempty"`
	Down           bool              `boil:"down" json:"down" toml:"down" yaml:"down"`
	Enable         bool              `boil:"enable" json:"enable" toml:"enable" yaml:"enable"`
	AssetID        null.Int          `boil:"asset_id" json:"asset_id,omitempty" toml:"asset_id" yaml:"asset_id,omitempty"`
	Subtype        string            `boil:"subtype" json:"subtype" toml:"subtype" yaml:"subtype"`
	Attribute      string            `boil:"attribute" json:"attribute" toml:"attribute" yaml:"attribute"`
	Scale          null.Float64      `boil:"scale" json:"scale,omitempty" toml:"scale" yaml:"scale,omitempty"`
	Zero           null.Float64      `boil:"zero" json:"zero,omitempty" toml:"zero" yaml:"zero,omitempty"`
	Mask           types.Int64Array  `boil:"mask" json:"mask,omitempty" toml:"mask" yaml:"mask,omitempty"`
	MaskAttributes types.StringArray `boil:"mask_attributes" json:"mask_attributes,omitempty" toml:"mask_attributes" yaml:"mask_attributes,omitempty"`
	DeadTime       null.Int          `boil:"dead_time" json:"dead_time,omitempty" toml:"dead_time" yaml:"dead_time,omitempty"`
	DeadBand       null.Float64      `boil:"dead_band" json:"dead_band,omitempty" toml:"dead_band" yaml:"dead_band,omitempty"`
	Filter         null.String       `boil:"filter" json:"filter,omitempty" toml:"filter" yaml:"filter,omitempty"`
	Tau            null.Float64      `boil:"tau" json:"tau,omitempty" toml:"tau" yaml:"tau,omitempty"`

	R *iosysAccessR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L iosysAccessL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var IosysAccessColumns = struct {
	ID             string
	DeviceID       string
	Iosvar         string
	Iostype        string
	Down           string
	Enable         string
	AssetID        string
	Subtype        string
	Attribute      string
	Scale          string
	Zero           string
	Mask           string
	MaskAttributes string
	DeadTime       string
	DeadBand       string
	Filter         string
	Tau            string
}{
	ID:             "id",
	DeviceID:       "device_id",
	Iosvar:         "iosvar",
	Iostype:        "iostype",
	Down:           "down",
	Enable:         "enable",
	AssetID:        "asset_id",
	Subtype:        "subtype",
	Attribute:      "attribute",
	Scale:          "scale",
	Zero:           "zero",
	Mask:           "mask",
	MaskAttributes: "mask_attributes",
	DeadTime:       "dead_time",
	DeadBand:       "dead_band",
	Filter:         "filter",
	Tau:            "tau",
}

var IosysAccessTableColumns = struct {
	ID             string
	DeviceID       string
	Iosvar         string
	Iostype        string
	Down           string
	Enable         string
	AssetID        string
	Subtype        string
	Attribute      string
	Scale          string
	Zero           string
	Mask           string
	MaskAttributes string
	DeadTime       string
	DeadBand       string
	Filter         string
	Tau            string
}{
	ID:             "iosys_access.id",
	DeviceID:       "iosys_access.device_id",
	Iosvar:         "iosys_access.iosvar",
	Iostype:        "iosys_access.iostype",
	Down:           "iosys_access.down",
	Enable:         "iosys_access.enable",
	AssetID:        "iosys_access.asset_id",
	Subtype:        "iosys_access.subtype",
	Attribute:      "iosys_access.attribute",
	Scale:          "iosys_access.scale",
	Zero:           "iosys_access.zero",
	Mask:           "iosys_access.mask",
	MaskAttributes: "iosys_access.mask_attributes",
	DeadTime:       "iosys_access.dead_time",
	DeadBand:       "iosys_access.dead_band",
	Filter:         "iosys_access.filter",
	Tau:            "iosys_access.tau",
}

// Generated where

type whereHelpertypes_Int64Array struct{ field string }

func (w whereHelpertypes_Int64Array) EQ(x types.Int64Array) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpertypes_Int64Array) NEQ(x types.Int64Array) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpertypes_Int64Array) LT(x types.Int64Array) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpertypes_Int64Array) LTE(x types.Int64Array) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpertypes_Int64Array) GT(x types.Int64Array) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpertypes_Int64Array) GTE(x types.Int64Array) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

func (w whereHelpertypes_Int64Array) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpertypes_Int64Array) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

var IosysAccessWhere = struct {
	ID             whereHelperint
	DeviceID       whereHelperint
	Iosvar         whereHelperstring
	Iostype        whereHelpernull_String
	Down           whereHelperbool
	Enable         whereHelperbool
	AssetID        whereHelpernull_Int
	Subtype        whereHelperstring
	Attribute      whereHelperstring
	Scale          whereHelpernull_Float64
	Zero           whereHelpernull_Float64
	Mask           whereHelpertypes_Int64Array
	MaskAttributes whereHelpertypes_StringArray
	DeadTime       whereHelpernull_Int
	DeadBand       whereHelpernull_Float64
	Filter         whereHelpernull_String
	Tau            whereHelpernull_Float64
}{
	ID:             whereHelperint{field: "\"iosys_access\".\"id\""},
	DeviceID:       whereHelperint{field: "\"iosys_access\".\"device_id\""},
	Iosvar:         whereHelperstring{field: "\"iosys_access\".\"iosvar\""},
	Iostype:        whereHelpernull_String{field: "\"iosys_access\".\"iostype\""},
	Down:           whereHelperbool{field: "\"iosys_access\".\"down\""},
	Enable:         whereHelperbool{field: "\"iosys_access\".\"enable\""},
	AssetID:        whereHelpernull_Int{field: "\"iosys_access\".\"asset_id\""},
	Subtype:        whereHelperstring{field: "\"iosys_access\".\"subtype\""},
	Attribute:      whereHelperstring{field: "\"iosys_access\".\"attribute\""},
	Scale:          whereHelpernull_Float64{field: "\"iosys_access\".\"scale\""},
	Zero:           whereHelpernull_Float64{field: "\"iosys_access\".\"zero\""},
	Mask:           whereHelpertypes_Int64Array{field: "\"iosys_access\".\"mask\""},
	MaskAttributes: whereHelpertypes_StringArray{field: "\"iosys_access\".\"mask_attributes\""},
	DeadTime:       whereHelpernull_Int{field: "\"iosys_access\".\"dead_time\""},
	DeadBand:       whereHelpernull_Float64{field: "\"iosys_access\".\"dead_band\""},
	Filter:         whereHelpernull_String{field: "\"iosys_access\".\"filter\""},
	Tau:            whereHelpernull_Float64{field: "\"iosys_access\".\"tau\""},
}

// IosysAccessRels is where relationship names are stored.
var IosysAccessRels = struct {
}{}

// iosysAccessR is where relationships are stored.
type iosysAccessR struct {
}

// NewStruct creates a new relationship struct
func (*iosysAccessR) NewStruct() *iosysAccessR {
	return &iosysAccessR{}
}

// iosysAccessL is where Load methods for each relationship are stored.
type iosysAccessL struct{}

var (
	iosysAccessAllColumns            = []string{"id", "device_id", "iosvar", "iostype", "down", "enable", "asset_id", "subtype", "attribute", "scale", "zero", "mask", "mask_attributes", "dead_time", "dead_band", "filter", "tau"}
	iosysAccessColumnsWithoutDefault = []string{"id", "device_id", "iosvar", "subtype", "attribute"}
	iosysAccessColumnsWithDefault    = []string{"iostype", "down", "enable", "asset_id", "scale", "zero", "mask", "mask_attributes", "dead_time", "dead_band", "filter", "tau"}
	iosysAccessPrimaryKeyColumns     = []string{"id"}
	iosysAccessGeneratedColumns      = []string{}
)

type (
	// IosysAccessSlice is an alias for a slice of pointers to IosysAccess.
	// This should almost always be used instead of []IosysAccess.
	IosysAccessSlice []*IosysAccess
	// IosysAccessHook is the signature for custom IosysAccess hook methods
	IosysAccessHook func(context.Context, boil.ContextExecutor, *IosysAccess) error

	iosysAccessQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	iosysAccessType                 = reflect.TypeOf(&IosysAccess{})
	iosysAccessMapping              = queries.MakeStructMapping(iosysAccessType)
	iosysAccessPrimaryKeyMapping, _ = queries.BindMapping(iosysAccessType, iosysAccessMapping, iosysAccessPrimaryKeyColumns)
	iosysAccessInsertCacheMut       sync.RWMutex
	iosysAccessInsertCache          = make(map[string]insertCache)
	iosysAccessUpdateCacheMut       sync.RWMutex
	iosysAccessUpdateCache          = make(map[string]updateCache)
	iosysAccessUpsertCacheMut       sync.RWMutex
	iosysAccessUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var iosysAccessAfterSelectHooks []IosysAccessHook

var iosysAccessBeforeInsertHooks []IosysAccessHook
var iosysAccessAfterInsertHooks []IosysAccessHook

var iosysAccessBeforeUpdateHooks []IosysAccessHook
var iosysAccessAfterUpdateHooks []IosysAccessHook

var iosysAccessBeforeDeleteHooks []IosysAccessHook
var iosysAccessAfterDeleteHooks []IosysAccessHook

var iosysAccessBeforeUpsertHooks []IosysAccessHook
var iosysAccessAfterUpsertHooks []IosysAccessHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *IosysAccess) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range iosysAccessAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *IosysAccess) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range iosysAccessBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *IosysAccess) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range iosysAccessAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *IosysAccess) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range iosysAccessBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *IosysAccess) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range iosysAccessAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *IosysAccess) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range iosysAccessBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *IosysAccess) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range iosysAccessAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *IosysAccess) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range iosysAccessBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *IosysAccess) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range iosysAccessAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddIosysAccessHook registers your hook function for all future operations.
func AddIosysAccessHook(hookPoint boil.HookPoint, iosysAccessHook IosysAccessHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		iosysAccessAfterSelectHooks = append(iosysAccessAfterSelectHooks, iosysAccessHook)
	case boil.BeforeInsertHook:
		iosysAccessBeforeInsertHooks = append(iosysAccessBeforeInsertHooks, iosysAccessHook)
	case boil.AfterInsertHook:
		iosysAccessAfterInsertHooks = append(iosysAccessAfterInsertHooks, iosysAccessHook)
	case boil.BeforeUpdateHook:
		iosysAccessBeforeUpdateHooks = append(iosysAccessBeforeUpdateHooks, iosysAccessHook)
	case boil.AfterUpdateHook:
		iosysAccessAfterUpdateHooks = append(iosysAccessAfterUpdateHooks, iosysAccessHook)
	case boil.BeforeDeleteHook:
		iosysAccessBeforeDeleteHooks = append(iosysAccessBeforeDeleteHooks, iosysAccessHook)
	case boil.AfterDeleteHook:
		iosysAccessAfterDeleteHooks = append(iosysAccessAfterDeleteHooks, iosysAccessHook)
	case boil.BeforeUpsertHook:
		iosysAccessBeforeUpsertHooks = append(iosysAccessBeforeUpsertHooks, iosysAccessHook)
	case boil.AfterUpsertHook:
		iosysAccessAfterUpsertHooks = append(iosysAccessAfterUpsertHooks, iosysAccessHook)
	}
}

// One returns a single iosysAccess record from the query.
func (q iosysAccessQuery) One(ctx context.Context, exec boil.ContextExecutor) (*IosysAccess, error) {
	o := &IosysAccess{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for iosys_access")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all IosysAccess records from the query.
func (q iosysAccessQuery) All(ctx context.Context, exec boil.ContextExecutor) (IosysAccessSlice, error) {
	var o []*IosysAccess

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to IosysAccess slice")
	}

	if len(iosysAccessAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all IosysAccess records in the query.
func (q iosysAccessQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count iosys_access rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q iosysAccessQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if iosys_access exists")
	}

	return count > 0, nil
}

// IosysAccesses retrieves all the records using an executor.
func IosysAccesses(mods ...qm.QueryMod) iosysAccessQuery {
	mods = append(mods, qm.From("\"iosys_access\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"iosys_access\".*"})
	}

	return iosysAccessQuery{q}
}

// FindIosysAccess retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindIosysAccess(ctx context.Context, exec boil.ContextExecutor, iD int, selectCols ...string) (*IosysAccess, error) {
	iosysAccessObj := &IosysAccess{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"iosys_access\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, iosysAccessObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from iosys_access")
	}

	if err = iosysAccessObj.doAfterSelectHooks(ctx, exec); err != nil {
		return iosysAccessObj, err
	}

	return iosysAccessObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *IosysAccess) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no iosys_access provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(iosysAccessColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	iosysAccessInsertCacheMut.RLock()
	cache, cached := iosysAccessInsertCache[key]
	iosysAccessInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			iosysAccessAllColumns,
			iosysAccessColumnsWithDefault,
			iosysAccessColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(iosysAccessType, iosysAccessMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(iosysAccessType, iosysAccessMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"iosys_access\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"iosys_access\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into iosys_access")
	}

	if !cached {
		iosysAccessInsertCacheMut.Lock()
		iosysAccessInsertCache[key] = cache
		iosysAccessInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the IosysAccess.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *IosysAccess) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	iosysAccessUpdateCacheMut.RLock()
	cache, cached := iosysAccessUpdateCache[key]
	iosysAccessUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			iosysAccessAllColumns,
			iosysAccessPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update iosys_access, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"iosys_access\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, iosysAccessPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(iosysAccessType, iosysAccessMapping, append(wl, iosysAccessPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update iosys_access row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for iosys_access")
	}

	if !cached {
		iosysAccessUpdateCacheMut.Lock()
		iosysAccessUpdateCache[key] = cache
		iosysAccessUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q iosysAccessQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for iosys_access")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for iosys_access")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o IosysAccessSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), iosysAccessPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"iosys_access\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, iosysAccessPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in iosysAccess slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all iosysAccess")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *IosysAccess) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no iosys_access provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(iosysAccessColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	iosysAccessUpsertCacheMut.RLock()
	cache, cached := iosysAccessUpsertCache[key]
	iosysAccessUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			iosysAccessAllColumns,
			iosysAccessColumnsWithDefault,
			iosysAccessColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			iosysAccessAllColumns,
			iosysAccessPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("models: unable to upsert iosys_access, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(iosysAccessPrimaryKeyColumns))
			copy(conflict, iosysAccessPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"iosys_access\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(iosysAccessType, iosysAccessMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(iosysAccessType, iosysAccessMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "models: unable to upsert iosys_access")
	}

	if !cached {
		iosysAccessUpsertCacheMut.Lock()
		iosysAccessUpsertCache[key] = cache
		iosysAccessUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single IosysAccess record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *IosysAccess) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no IosysAccess provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), iosysAccessPrimaryKeyMapping)
	sql := "DELETE FROM \"iosys_access\" WHERE \"id\"=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from iosys_access")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for iosys_access")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q iosysAccessQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no iosysAccessQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from iosys_access")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for iosys_access")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o IosysAccessSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(iosysAccessBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), iosysAccessPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"iosys_access\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, iosysAccessPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from iosysAccess slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for iosys_access")
	}

	if len(iosysAccessAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *IosysAccess) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindIosysAccess(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *IosysAccessSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := IosysAccessSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), iosysAccessPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"iosys_access\".* FROM \"iosys_access\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, iosysAccessPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in IosysAccessSlice")
	}

	*o = slice

	return nil
}

// IosysAccessExists checks if the IosysAccess row exists.
func IosysAccessExists(ctx context.Context, exec boil.ContextExecutor, iD int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"iosys_access\" where \"id\"=$1 limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if iosys_access exists")
	}

	return exists, nil
}
